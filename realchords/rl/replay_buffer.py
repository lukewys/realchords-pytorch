"""Custom replay buffer class."""

import torch
from typing import List, Optional
from dataclasses import dataclass
import torch.nn.functional as F

from realchords.rl.openrlhf_local import NaiveReplayBuffer
from realchords.rl.experience_maker import Experience


def zero_pad_sequences(
    sequences: List[torch.Tensor], side: str = "left"
) -> torch.Tensor:
    """Pad sequences with zeros to the same length."""
    assert side in ("left", "right")
    max_len = max(seq.size(0) for seq in sequences)
    padded_sequences = []
    for seq in sequences:
        pad_len = max_len - seq.size(0)
        padding = (pad_len, 0) if side == "left" else (0, pad_len)
        padded_sequences.append(F.pad(seq, padding))
    return torch.stack(padded_sequences, dim=0)


@dataclass
class BufferItem:
    """BufferItem is an item of experience data.

    Compared to the original BufferItem, this class has the following changes:
    1. Add "targets" to the keys.

    Shapes of each tensor:
    targets: (S), the ground truth targets of the sequences from the batch.
    sequences: (S)
    action_log_probs: (A)
    base_action_log_probs: (A)
    values: (1)
    returns: (1)
    advantages: (1)
    attention_mask: (S)
    action_mask: (A)

    "A" is the number of actions.
    """

    targets: torch.Tensor
    sequences: torch.Tensor
    action_log_probs: torch.Tensor
    base_action_log_probs: torch.Tensor
    values: torch.Tensor
    returns: torch.Tensor
    advantages: torch.Tensor
    attention_mask: Optional[torch.LongTensor]
    action_mask: Optional[torch.BoolTensor]
    info: Optional[dict]


def split_experience_batch(experience: Experience) -> List[BufferItem]:
    """From openrlhf.trainer.ppo_utils.replay_buffer.split_experience_batch,

    add "targets" to the keys.
    """
    batch_size = len(experience.sequences)
    batch_kwargs = [{} for _ in range(batch_size)]
    keys = (
        "targets",
        "sequences",
        "action_log_probs",
        "base_action_log_probs",
        "values",
        "returns",
        "advantages",
        "attention_mask",
        "action_mask",
    )
    for key in keys:
        value = getattr(experience, key)
        if value is None:
            for i in range(batch_size):
                batch_kwargs[i][key] = None
            continue
        vals = value
        if isinstance(vals, torch.Tensor):
            vals = torch.unbind(vals)
        assert batch_size == len(vals)
        for i, v in enumerate(vals):
            batch_kwargs[i][key] = v

    for i in range(batch_size):
        batch_kwargs[i]["info"] = {}
    for k, v in experience.info.items():
        vals = torch.unbind(v)
        assert batch_size == len(vals)
        for i, vv in enumerate(vals):
            if isinstance(vv, torch.Tensor):
                assert (
                    vv.numel() == 1
                ), f"info[{k}] must be a scalar tensor, but got {vv.shape}"
                vv = vv.item()
            batch_kwargs[i]["info"][k] = vv

    items = [BufferItem(**kwargs) for kwargs in batch_kwargs]
    return items


def make_experience_batch(
    items: List[BufferItem], packing_samples=False
) -> Experience:
    """From openrlhf.trainer.ppo_utils.replay_buffer.make_experience_batch,

    add targets to the keys.
    """
    kwargs = {}
    keys = (
        "targets",
        "sequences",
        "action_log_probs",
        "base_action_log_probs",
        "values",
        "returns",
        "advantages",
        "attention_mask",
        "action_mask",
    )
    for key in keys:
        vals = [getattr(item, key) for item in items]
        if not packing_samples:
            batch_data = (
                zero_pad_sequences(vals, "left")
                if vals[0] is not None
                else None
            )
        else:
            batch_data = vals if vals[0] is not None else None
        kwargs[key] = batch_data

    kwargs["info"] = {}
    for key in items[0].info.keys():
        vals = torch.tensor([item.info[key] for item in items])
        kwargs["info"][key] = vals
    return Experience(**kwargs)


class RealchordsReplayBuffer(NaiveReplayBuffer):
    """Custom replay buffer class.

    Compared to the original replay buffer, this class has the following changes:
    1. Removed the feature that it will consider sequence that
        has non-consecutive tokens generated by model (packing samples).
    2. It will not remove the padding in the sequences (because of the above reason).
    3. Additionally include "targets" in the experience.


    Args:
        sample_batch_size (int): Batch size when sampling.
        limit (int, optional): Limit of number of experience samples. A number <= 0 means unlimited. Defaults to 0.
        cpu_offload (bool, optional): Whether to offload experience to cpu when sampling. Defaults to True.
    """

    @torch.no_grad()
    def append(self, experience: Experience) -> None:
        if self.cpu_offload:
            experience.to_device(torch.device("cpu"))
        items = split_experience_batch(experience)
        # removed the remove padding here

        # the packed samples comes with no padding
        # if not self.packing_samples:
        #     items = remove_padding_in_sequences(items)

        self.items.extend(items)
        if self.limit > 0:
            samples_to_remove = len(self.items) - self.limit
            if samples_to_remove > 0:
                self.items = self.items[samples_to_remove:]

    def collate_fn(self, batch) -> Experience:
        experience = make_experience_batch(batch, self.packing_samples)
        return experience
